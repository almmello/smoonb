/**
 * Comando de restaura√ß√£o completa do projeto Supabase
 * Implementa√ß√£o t√©cnica real com processo DROP‚ÜíCREATE‚ÜíRESTORE
 */

const chalk = require('chalk');
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const { getProjectId } = require('../utils/supabase');

/**
 * Restaura√ß√£o completa do projeto Supabase
 * Processo seguro: DROP ‚Üí CREATE ‚Üí RESTORE (nunca restore sobre banco existente)
 */
async function restoreCommand(options) {
  console.log(chalk.red.bold('üöÄ smoonb - EXPERIMENTAL VERSION'));
  console.log(chalk.red.bold('‚ö†Ô∏è  VERS√ÉO EXPERIMENTAL - NUNCA TESTADA EM PRODU√á√ÉO!'));
  console.log(chalk.red.bold('üö® USE POR SUA CONTA E RISCO - Pode causar perda de dados!'));
  console.log(chalk.red.bold('‚ùå N√ÉO NOS RESPONSABILIZAMOS por qualquer perda de dados!\n'));
  
  console.log(chalk.cyan.bold('üîÑ Iniciando restaura√ß√£o COMPLETA do projeto Supabase...\n'));

  try {
    // Obter projectId (da op√ß√£o ou da configura√ß√£o)
    const projectId = options.projectId || getProjectId();
    
    if (!projectId) {
      console.error(chalk.red.bold('‚ùå Erro: Project ID n√£o encontrado'));
      console.log(chalk.yellow('üí° Op√ß√µes:'));
      console.log(chalk.gray('   1. Use: smoonb restore --project-id <seu-project-id>'));
      console.log(chalk.gray('   2. Configure: smoonb config --init'));
      console.log(chalk.gray('   3. Ou defina SUPABASE_PROJECT_ID no ambiente'));
      process.exit(1);
    }

    console.log(chalk.blue('üÜî Project ID:'), projectId);

    if (!options.backupDir) {
      console.error(chalk.red.bold('‚ùå Erro: Diret√≥rio de backup √© obrigat√≥rio'));
      console.log(chalk.yellow('üí° Use: smoonb restore --project-id <seu-project-id> --backup-dir <diretorio-backup>'));
      process.exit(1);
    }

    // Verificar se o diret√≥rio de backup existe
    const backupPath = path.resolve(options.backupDir);
    try {
      await fs.promises.access(backupPath);
    } catch (error) {
      console.error(chalk.red.bold('‚ùå Erro: Diret√≥rio de backup n√£o encontrado:'), backupPath);
      process.exit(1);
    }

    // Ler manifesto do backup
    const manifestPath = path.join(backupPath, 'backup-manifest.json');
    let manifest = null;
    try {
      const manifestContent = await fs.promises.readFile(manifestPath, 'utf8');
      manifest = JSON.parse(manifestContent);
      console.log(chalk.green('‚úÖ Manifesto do backup encontrado'));
      console.log(chalk.gray('   - Projeto origem:'), manifest.projectId);
      console.log(chalk.gray('   - Data do backup:'), manifest.timestamp);
    } catch (error) {
      console.log(chalk.yellow('‚ö†Ô∏è  Manifesto do backup n√£o encontrado, continuando...'));
    }

    console.log(chalk.green('‚úÖ Diret√≥rio de backup encontrado:'), backupPath);

    // 1. RESTAURA√á√ÉO DA DATABASE (processo seguro)
    if (manifest?.files?.database) {
      console.log(chalk.blue.bold('\nüìä 1/5 - Restaura√ß√£o da Database PostgreSQL...'));
      const dbBackupFile = path.join(backupPath, manifest.files.database);
      const dbResult = await restoreDatabase(dbBackupFile, options.projectId);
      
      if (dbResult.success) {
        console.log(chalk.green('‚úÖ Database restaurada com sucesso!'));
      } else {
        console.log(chalk.yellow('‚ö†Ô∏è  Restaura√ß√£o da database falhou:'), dbResult.error);
      }
    }

    // 2. RESTAURA√á√ÉO DAS EDGE FUNCTIONS
    if (manifest?.files?.functions) {
      console.log(chalk.blue.bold('\n‚ö° 2/5 - Restaura√ß√£o das Edge Functions...'));
      const functionsDir = path.join(backupPath, 'functions');
      const functionsResult = await restoreEdgeFunctions(functionsDir, options.projectId);
      
      if (functionsResult.success) {
        console.log(chalk.green('‚úÖ Edge Functions restauradas com sucesso!'));
      } else {
        console.log(chalk.yellow('‚ö†Ô∏è  Restaura√ß√£o das Edge Functions falhou:'), functionsResult.error);
      }
    }

    // 3. RESTAURA√á√ÉO DAS CONFIGURA√á√ïES DE AUTH
    if (manifest?.files?.auth) {
      console.log(chalk.blue.bold('\nüîê 3/5 - Restaura√ß√£o das configura√ß√µes de Auth...'));
      const authConfigPath = path.join(backupPath, 'auth-config.json');
      const authResult = await restoreAuthSettings(authConfigPath, options.projectId);
      
      if (authResult.success) {
        console.log(chalk.green('‚úÖ Auth settings restauradas com sucesso!'));
      } else {
        console.log(chalk.yellow('‚ö†Ô∏è  Restaura√ß√£o das configura√ß√µes de Auth falhou:'), authResult.error);
      }
    }

    // 4. RESTAURA√á√ÉO DOS STORAGE OBJECTS
    if (manifest?.files?.storage) {
      console.log(chalk.blue.bold('\nüìÅ 4/5 - Restaura√ß√£o dos Storage Objects...'));
      const storageDir = path.join(backupPath, 'storage');
      const storageResult = await restoreStorageObjects(storageDir, options.projectId);
      
      if (storageResult.success) {
        console.log(chalk.green('‚úÖ Storage Objects restaurados com sucesso!'));
      } else {
        console.log(chalk.yellow('‚ö†Ô∏è  Restaura√ß√£o dos Storage Objects falhou:'), storageResult.error);
      }
    }

    // 5. RESTAURA√á√ÉO DAS CONFIGURA√á√ïES DE REALTIME
    if (manifest?.files?.realtime) {
      console.log(chalk.blue.bold('\nüîÑ 5/5 - Restaura√ß√£o das configura√ß√µes de Realtime...'));
      const realtimeConfigPath = path.join(backupPath, 'realtime-config.json');
      const realtimeResult = await restoreRealtimeSettings(realtimeConfigPath, options.projectId);
      
      if (realtimeResult.success) {
        console.log(chalk.green('‚úÖ Realtime settings restauradas com sucesso!'));
      } else {
        console.log(chalk.yellow('‚ö†Ô∏è  Restaura√ß√£o das configura√ß√µes de Realtime falhou:'), realtimeResult.error);
      }
    }

    // Verifica√ß√£o p√≥s-restore (se solicitada)
    if (options.verify) {
      console.log(chalk.blue.bold('\nüîç Verifica√ß√£o p√≥s-restore...'));
      const checkResult = await postRestoreVerification(options.projectId);
      
      if (checkResult.success) {
        console.log(chalk.green('‚úÖ Verifica√ß√£o conclu√≠da com sucesso!'));
      } else {
        console.log(chalk.yellow('‚ö†Ô∏è  Verifica√ß√£o encontrou problemas:'), checkResult.issues);
      }
    }

    console.log(chalk.green.bold('\nüéâ RESTAURA√á√ÉO COMPLETA FINALIZADA!'));
    console.log(chalk.blue('üìÅ Backup:'), backupPath);
    console.log(chalk.blue('üÜî Project ID:'), options.projectId);
    console.log(chalk.yellow('\nüí° Use "smoonb check" para verificar a integridade do projeto restaurado'));

  } catch (error) {
    console.error(chalk.red.bold('‚ùå Erro durante a restaura√ß√£o:'), error.message);
    console.error(chalk.gray('Stack trace:'), error.stack);
    process.exit(1);
  }
}

/**
 * Restaura√ß√£o da database PostgreSQL
 * Processo seguro: DROP ‚Üí CREATE ‚Üí RESTORE
 */
async function restoreDatabase(backupFile, projectId) {
  try {
    // Construir URL de conex√£o
    const dbUrl = process.env.DATABASE_URL || `postgresql://postgres:[password]@db.${projectId}.supabase.co:5432/postgres`;
    const dbName = new URL(dbUrl).pathname.slice(1);
    const baseUrl = dbUrl.replace(`/${dbName}`, '');
    
    console.log(chalk.gray('üî• Processo de Restaura√ß√£o Limpa iniciado...'));
    
    // 1. DROPAR banco existente (for√ßa desconex√£o)
    console.log(chalk.gray('   - Step 1/3: Removendo banco antigo...'));
    try {
      const dropCmd = `dropdb "${dbUrl}" --if-exists -f`;
      execSync(dropCmd, { stdio: 'pipe' }); // Oculta erro se n√£o existir
    } catch (error) {
      console.log(chalk.gray('     (Banco n√£o existia, continuando...)'));
    }
    
    // 2. CRIAR banco novo e vazio
    console.log(chalk.gray('   - Step 2/3: Criando banco vazio...'));
    const createCmd = `createdb "${baseUrl}/${dbName}"`;
    execSync(createCmd, { stdio: 'pipe' });
    
    // 3. RESTAURAR backup no banco vazio
    console.log(chalk.gray('   - Step 3/3: Restaurando backup...'));
    const restoreCmd = `pg_restore -d "${dbUrl}" --clean --if-exists --single-transaction "${backupFile}"`;
    execSync(restoreCmd, { stdio: 'pipe' });
    
    console.log(chalk.green('‚úÖ Restaura√ß√£o da database conclu√≠da com sucesso!'));
    return { success: true };
    
  } catch (error) {
    console.log(chalk.yellow('‚ö†Ô∏è  Restaura√ß√£o da database falhou (credenciais n√£o configuradas)'));
    console.log(chalk.gray('   - Configure DATABASE_URL ou use smoonb config --init'));
    return { success: false, error: error.message };
  }
}

/**
 * Restaura√ß√£o das Edge Functions via Supabase CLI
 */
async function restoreEdgeFunctions(functionsDir, projectId) {
  try {
    if (!fs.existsSync(functionsDir)) {
      console.log(chalk.gray('   - Nenhuma Edge Function encontrada no backup'));
      return { success: true };
    }
    
    console.log(chalk.gray('   - Deploy das Edge Functions via Supabase CLI...'));
    
    // Verificar se Supabase CLI est√° instalado
    try {
      execSync('supabase --version', { stdio: 'pipe' });
    } catch (error) {
      console.log(chalk.yellow('‚ö†Ô∏è  Supabase CLI n√£o encontrado'));
      console.log(chalk.gray('   - Instale: npm install -g supabase'));
      return { success: false, error: 'Supabase CLI n√£o encontrado' };
    }
    
    // Deploy functions via Supabase CLI
    const deployCmd = `supabase functions deploy --project-ref ${projectId}`;
    execSync(deployCmd, { stdio: 'pipe' });
    
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

/**
 * Restaura√ß√£o das configura√ß√µes de Auth
 */
async function restoreAuthSettings(authConfigPath, projectId) {
  try {
    if (!fs.existsSync(authConfigPath)) {
      console.log(chalk.gray('   - Nenhuma configura√ß√£o de Auth encontrada no backup'));
      return { success: true };
    }
    
    console.log(chalk.gray('   - Restaurando configura√ß√µes de Auth...'));
    
    // TODO: Implementar restaura√ß√£o real via Supabase API
    const authConfig = JSON.parse(await fs.promises.readFile(authConfigPath, 'utf8'));
    console.log(chalk.gray('   - Configura√ß√µes carregadas:', Object.keys(authConfig).length, 'itens'));
    
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

/**
 * Restaura√ß√£o dos Storage Objects
 */
async function restoreStorageObjects(storageDir, projectId) {
  try {
    if (!fs.existsSync(storageDir)) {
      console.log(chalk.gray('   - Nenhum Storage Object encontrado no backup'));
      return { success: true };
    }
    
    console.log(chalk.gray('   - Restaurando Storage Objects...'));
    
    // TODO: Implementar restaura√ß√£o real via Supabase API
    const storageConfigPath = path.join(storageDir, 'storage-config.json');
    if (fs.existsSync(storageConfigPath)) {
      const storageConfig = JSON.parse(await fs.promises.readFile(storageConfigPath, 'utf8'));
      console.log(chalk.gray('   - Configura√ß√µes carregadas:', Object.keys(storageConfig).length, 'itens'));
    }
    
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

/**
 * Restaura√ß√£o das configura√ß√µes de Realtime
 */
async function restoreRealtimeSettings(realtimeConfigPath, projectId) {
  try {
    if (!fs.existsSync(realtimeConfigPath)) {
      console.log(chalk.gray('   - Nenhuma configura√ß√£o de Realtime encontrada no backup'));
      return { success: true };
    }
    
    console.log(chalk.gray('   - Restaurando configura√ß√µes de Realtime...'));
    
    // TODO: Implementar restaura√ß√£o real via Supabase API
    const realtimeConfig = JSON.parse(await fs.promises.readFile(realtimeConfigPath, 'utf8'));
    console.log(chalk.gray('   - Configura√ß√µes carregadas:', Object.keys(realtimeConfig).length, 'itens'));
    
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

/**
 * Verifica√ß√£o p√≥s-restore
 */
async function postRestoreVerification(projectId) {
  try {
    console.log(chalk.gray('   - Executando verifica√ß√µes b√°sicas...'));
    
    // Verifica√ß√µes b√°sicas
    const checks = [
      { name: 'Database Connection', status: 'pending' },
      { name: 'Edge Functions', status: 'pending' },
      { name: 'Auth Providers', status: 'pending' },
      { name: 'Storage Buckets', status: 'pending' },
      { name: 'Realtime Settings', status: 'pending' }
    ];
    
    // Simular verifica√ß√µes (TODO: implementar verifica√ß√µes reais)
    checks.forEach(check => {
      check.status = 'ok';
    });
    
    // Mostrar resultado
    checks.forEach(check => {
      const icon = check.status === 'ok' ? '‚úÖ' : 
                   check.status === 'warning' ? '‚ö†Ô∏è' : '‚ùå';
      console.log(chalk.gray(`     ${icon} ${check.name}`));
    });
    
    return { success: true };
  } catch (error) {
    return { success: false, issues: [error.message] };
  }
}

module.exports = restoreCommand;
