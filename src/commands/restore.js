const chalk = require('chalk');
const path = require('path');
const fs = require('fs');
const inquirer = require('inquirer');
const { ensureBin, runCommand } = require('../utils/cli');
const { readConfig, validateFor } = require('../utils/config');
const { showBetaBanner } = require('../utils/banner');

// Exportar FUN√á√ÉO em vez de objeto Command
module.exports = async (options) => {
  showBetaBanner();
  
  try {
    // Verificar se psql est√° dispon√≠vel
    const psqlPath = await ensureBin('psql');
    if (!psqlPath) {
      console.error(chalk.red('‚ùå psql n√£o encontrado'));
      console.log(chalk.yellow('üí° Instale PostgreSQL:'));
      console.log(chalk.yellow('  https://www.postgresql.org/download/'));
      process.exit(1);
    }

    // Carregar configura√ß√£o
    const config = await readConfig();
    validateFor(config, 'restore');

    // Resolver URL da database
    const databaseUrl = options.dbUrl || config.supabase.databaseUrl;
    if (!databaseUrl) {
      console.error(chalk.red('‚ùå databaseUrl n√£o configurada'));
      console.log(chalk.yellow('üí° Configure databaseUrl no .smoonbrc ou use --db-url'));
      process.exit(1);
    }

    console.log(chalk.blue(`üîç Procurando backups em: ${config.backup.outputDir || './backups'}`));

    // Listar backups dispon√≠veis
    const backups = await listAvailableBackups(config.backup.outputDir || './backups');
    
    if (backups.length === 0) {
      console.error(chalk.red('‚ùå Nenhum backup encontrado'));
      console.log(chalk.yellow('üí° Execute primeiro: npx smoonb backup'));
      process.exit(1);
    }

    // Sele√ß√£o interativa do backup
    const selectedBackup = await selectBackup(backups);
    
    console.log(chalk.blue(`üöÄ Iniciando restaura√ß√£o do backup: ${selectedBackup.name}`));
    console.log(chalk.blue(`üéØ Database destino: ${databaseUrl.replace(/:[^:]*@/, ':***@')}`));

    // Verificar se √© clean restore
    if (config.restore.cleanRestore) {
      await checkCleanRestore(databaseUrl);
    }

    // Executar restaura√ß√£o
    await performRestore(selectedBackup.path, databaseUrl);

    // Verifica√ß√£o p√≥s-restore
    if (config.restore.verifyAfterRestore) {
      console.log(chalk.blue('\nüîç Executando verifica√ß√£o p√≥s-restore...'));
      console.log(chalk.yellow('üí° Execute manualmente: npx smoonb check'));
    }

    console.log(chalk.green('\nüéâ Restaura√ß√£o conclu√≠da com sucesso!'));

  } catch (error) {
    console.error(chalk.red(`‚ùå Erro na restaura√ß√£o: ${error.message}`));
    process.exit(1);
  }
};

// Listar backups dispon√≠veis
async function listAvailableBackups(backupsDir) {
  if (!fs.existsSync(backupsDir)) {
    return [];
  }

  const items = fs.readdirSync(backupsDir, { withFileTypes: true });
  const backups = [];

  for (const item of items) {
    if (item.isDirectory() && item.name.startsWith('backup-')) {
      const backupPath = path.join(backupsDir, item.name);
      const manifestPath = path.join(backupPath, 'backup-manifest.json');
      
      let manifest = null;
      if (fs.existsSync(manifestPath)) {
        try {
          manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
        } catch (error) {
          console.warn(chalk.yellow(`‚ö†Ô∏è Erro ao ler manifesto: ${item.name}`));
        }
      }

      const stats = fs.statSync(backupPath);
      
      backups.push({
        name: item.name,
        path: backupPath,
        created: manifest?.created_at || stats.birthtime.toISOString(),
        projectId: manifest?.project_id || 'Desconhecido',
        size: getDirectorySize(backupPath),
        manifest: manifest
      });
    }
  }

  // Ordenar por data de cria√ß√£o (mais recente primeiro)
  return backups.sort((a, b) => new Date(b.created) - new Date(a.created));
}

// Calcular tamanho do diret√≥rio
function getDirectorySize(dirPath) {
  let totalSize = 0;
  
  function calculateSize(itemPath) {
    const stats = fs.statSync(itemPath);
    
    if (stats.isDirectory()) {
      const items = fs.readdirSync(itemPath);
      for (const item of items) {
        calculateSize(path.join(itemPath, item));
      }
    } else {
      totalSize += stats.size;
    }
  }
  
  try {
    calculateSize(dirPath);
  } catch (error) {
    // Ignorar erros de acesso
  }
  
  return formatBytes(totalSize);
}

// Formatar bytes em formato leg√≠vel
function formatBytes(bytes) {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

// Sele√ß√£o interativa do backup
async function selectBackup(backups) {
  console.log(chalk.blue('\nüìã Backups dispon√≠veis:'));
  console.log(chalk.blue('‚ïê'.repeat(80)));
  
  const choices = backups.map((backup, index) => {
    const date = new Date(backup.created).toLocaleString('pt-BR');
    const projectInfo = backup.projectId !== 'Desconhecido' ? ` (${backup.projectId})` : '';
    
    return {
      name: `${index + 1}. ${backup.name}${projectInfo}\n   üìÖ ${date} | üì¶ ${backup.size}`,
      value: backup,
      short: backup.name
    };
  });

  const { selectedBackup } = await inquirer.prompt([
    {
      type: 'list',
      name: 'selectedBackup',
      message: 'Selecione o backup para restaurar:',
      choices: choices,
      pageSize: 10
    }
  ]);

  return selectedBackup;
}

// Verificar se √© poss√≠vel fazer clean restore
async function checkCleanRestore(databaseUrl) {
  try {
    console.log(chalk.blue('üîç Verificando se database est√° vazia...'));
    
    // Verificar se existem tabelas no schema public
    const checkQuery = `
      SELECT COUNT(*) as table_count 
      FROM information_schema.tables 
      WHERE table_schema = 'public' AND table_type = 'BASE TABLE';
    `;
    
    const { stdout } = await runCommand(
      `psql "${databaseUrl}" -t -c "${checkQuery}"`
    );
    
    const tableCount = parseInt(stdout.trim());
    
    if (tableCount > 0) {
      console.error(chalk.red('‚ùå Database n√£o est√° vazia!'));
      console.log(chalk.yellow('üí° Para clean restore, a database deve estar vazia'));
      console.log(chalk.yellow('üí° Op√ß√µes:'));
      console.log(chalk.yellow('  1. Criar uma nova database'));
      console.log(chalk.yellow('  2. Desabilitar cleanRestore no .smoonbrc'));
      console.log(chalk.yellow('  3. Limpar manualmente a database'));
      process.exit(1);
    }
    
    console.log(chalk.green('‚úÖ Database est√° vazia, prosseguindo com clean restore'));
    
  } catch (error) {
    console.log(chalk.yellow(`‚ö†Ô∏è N√£o foi poss√≠vel verificar database: ${error.message}`));
    console.log(chalk.yellow('üí° Prosseguindo com restaura√ß√£o...'));
  }
}

// Executar restaura√ß√£o usando psql
async function performRestore(backupDir, databaseUrl) {
  const sqlFiles = ['roles.sql', 'schema.sql', 'data.sql'];
  
  for (const sqlFile of sqlFiles) {
    const filePath = path.join(backupDir, sqlFile);
    
    if (!fs.existsSync(filePath)) {
      console.log(chalk.yellow(`‚ö†Ô∏è Arquivo ${sqlFile} n√£o encontrado, pulando...`));
      continue;
    }
    
    console.log(chalk.blue(`üìÑ Executando ${sqlFile}...`));
    
    try {
      let command;
      if (sqlFile === 'data.sql') {
        // Para dados, usar single-transaction
        command = `psql "${databaseUrl}" -v ON_ERROR_STOP=1 --single-transaction -f "${filePath}"`;
      } else {
        // Para roles e schema, usar ON_ERROR_STOP
        command = `psql "${databaseUrl}" -v ON_ERROR_STOP=1 -f "${filePath}"`;
      }
      
      const { stdout, stderr } = await runCommand(command);
      
      if (stderr && !stderr.includes('NOTICE')) {
        console.log(chalk.yellow(`‚ö†Ô∏è Avisos em ${sqlFile}: ${stderr}`));
      }
      
      console.log(chalk.green(`‚úÖ ${sqlFile} executado com sucesso`));
      
    } catch (error) {
      throw new Error(`Falha ao executar ${sqlFile}: ${error.message}`);
    }
  }
}