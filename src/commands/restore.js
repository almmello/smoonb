const chalk = require('chalk');
const path = require('path');
const fs = require('fs');
const { readConfig, getSourceProject, getTargetProject } = require('../utils/config');
const { showBetaBanner } = require('../utils/banner');

module.exports = async (options) => {
  showBetaBanner();
  
  try {
    const config = await readConfig();
    const targetProject = getTargetProject(config);
    
    console.log(chalk.blue(`üìÅ Buscando backups em: ${config.backup.outputDir || './backups'}`));
    
    // 1. Listar backups v√°lidos (.backup.gz)
    const validBackups = await listValidBackups(config.backup.outputDir || './backups');
    
    if (validBackups.length === 0) {
      console.error(chalk.red('‚ùå Nenhum backup v√°lido encontrado'));
      console.log(chalk.yellow('üí° Execute primeiro: npx smoonb backup'));
      process.exit(1);
    }
    
    // 2. Selecionar backup interativamente
    const selectedBackup = await selectBackupInteractive(validBackups);
    
    // 3. Perguntar quais componentes restaurar
    const components = await askRestoreComponents(selectedBackup.path);
    
    // 4. Mostrar resumo
    showRestoreSummary(selectedBackup, components, targetProject);
    
    // 5. Confirmar execu√ß√£o
    const confirmed = await confirmExecution();
    if (!confirmed) {
      console.log(chalk.yellow('Restaura√ß√£o cancelada.'));
      process.exit(0);
    }
    
    // 6. Executar restaura√ß√£o
    console.log(chalk.blue('\nüöÄ Iniciando restaura√ß√£o...'));
    
    // 6.1 Database
    await restoreDatabaseGz(
      path.join(selectedBackup.path, selectedBackup.backupFile),
      targetProject.targetDatabaseUrl
    );
    
    // 6.2 Edge Functions (se selecionado)
    if (components.edgeFunctions) {
      await restoreEdgeFunctions(selectedBackup.path, targetProject);
    }
    
    // 6.3 Storage Buckets (se selecionado)
    if (components.storage) {
      await restoreStorageBuckets(selectedBackup.path, targetProject);
    }
    
    // 6.4 Auth Settings (se selecionado)
    if (components.authSettings) {
      await restoreAuthSettings(selectedBackup.path, targetProject);
    }
    
    // 6.5 Database Settings (se selecionado)
    if (components.databaseSettings) {
      await restoreDatabaseSettings(selectedBackup.path, targetProject);
    }
    
    // 6.6 Realtime Settings (se selecionado)
    if (components.realtimeSettings) {
      await restoreRealtimeSettings(selectedBackup.path, targetProject);
    }
    
    console.log(chalk.green('\nüéâ Restaura√ß√£o completa finalizada!'));
    
  } catch (error) {
    console.error(chalk.red(`‚ùå Erro na restaura√ß√£o: ${error.message}`));
    process.exit(1);
  }
};

// Listar backups v√°lidos (apenas com .backup.gz)
async function listValidBackups(backupsDir) {
  if (!fs.existsSync(backupsDir)) {
    return [];
  }

  const items = fs.readdirSync(backupsDir, { withFileTypes: true });
  const validBackups = [];

  for (const item of items) {
    if (item.isDirectory() && item.name.startsWith('backup-')) {
      const backupPath = path.join(backupsDir, item.name);
      const files = fs.readdirSync(backupPath);
      const backupFile = files.find(file => file.endsWith('.backup.gz'));
      
      if (backupFile) {
        const manifestPath = path.join(backupPath, 'backup-manifest.json');
        let manifest = null;
        
        if (fs.existsSync(manifestPath)) {
          try {
            manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
          } catch (error) {
            // Ignorar erro de leitura do manifest
          }
        }

        const stats = fs.statSync(path.join(backupPath, backupFile));
        
        validBackups.push({
          name: item.name,
          path: backupPath,
          backupFile: backupFile,
          created: manifest?.created_at || stats.birthtime.toISOString(),
          projectId: manifest?.project_id || 'Desconhecido',
          size: formatBytes(stats.size),
          manifest: manifest
        });
      }
    }
  }

  return validBackups.sort((a, b) => new Date(b.created) - new Date(a.created));
}

// Formatar bytes
function formatBytes(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

// Sele√ß√£o interativa de backup
async function selectBackupInteractive(backups) {
  console.log(chalk.blue('\nüìã Backups dispon√≠veis:'));
  console.log(chalk.blue('‚ïê'.repeat(80)));
  
  backups.forEach((backup, index) => {
    const date = new Date(backup.created).toLocaleString('pt-BR');
    const projectInfo = backup.projectId !== 'Desconhecido' ? ` (${backup.projectId})` : '';
    
    console.log(`${index + 1}. ${backup.name}${projectInfo}`);
    console.log(`   üìÖ ${date} | üì¶ ${backup.size}`);
    console.log('');
  });
  
  const readline = require('readline').createInterface({
    input: process.stdin,
    output: process.stdout
  });
  
  const question = (query) => new Promise(resolve => readline.question(query, resolve));
  
  const choice = await question(`\nDigite o n√∫mero do backup para restaurar (1-${backups.length}): `);
  readline.close();
  
  const backupIndex = parseInt(choice) - 1;
  
  if (backupIndex < 0 || backupIndex >= backups.length) {
    throw new Error('N√∫mero inv√°lido');
  }
  
  return backups[backupIndex];
}

// Perguntar quais componentes restaurar
async function askRestoreComponents(backupPath) {
  const components = {
    edgeFunctions: true,
    storage: false,
    authSettings: false,
    databaseSettings: false,
    realtimeSettings: false
  };
  
  const readline = require('readline').createInterface({
    input: process.stdin,
    output: process.stdout
  });
  
  const question = (query) => new Promise(resolve => readline.question(query, resolve));
  
  console.log(chalk.blue('\nüì¶ Selecione os componentes para restaurar:'));
  
  // Edge Functions
  const edgeFunctionsDir = path.join(backupPath, 'edge-functions');
  if (fs.existsSync(edgeFunctionsDir) && fs.readdirSync(edgeFunctionsDir).length > 0) {
    const edgeChoice = await question('Deseja restaurar Edge Functions? (S/n): ');
    components.edgeFunctions = edgeChoice.toLowerCase() !== 'n';
  }
  
  // Storage Buckets
  const storageDir = path.join(backupPath, 'storage');
  if (fs.existsSync(storageDir) && fs.readdirSync(storageDir).length > 0) {
    const storageChoice = await question('Deseja restaurar Storage Buckets? (s/N): ');
    components.storage = storageChoice.toLowerCase() === 's';
  }
  
  // Auth Settings
  if (fs.existsSync(path.join(backupPath, 'auth-settings.json'))) {
    const authChoice = await question('Deseja restaurar Auth Settings? (s/N): ');
    components.authSettings = authChoice.toLowerCase() === 's';
  }
  
  // Database Settings
  const dbSettingsFiles = fs.readdirSync(backupPath)
    .filter(file => file.startsWith('database-settings-') && file.endsWith('.json'));
  if (dbSettingsFiles.length > 0) {
    const dbChoice = await question('Deseja restaurar Database Extensions and Settings? (s/N): ');
    components.databaseSettings = dbChoice.toLowerCase() === 's';
  }
  
  // Realtime Settings
  if (fs.existsSync(path.join(backupPath, 'realtime-settings.json'))) {
    const realtimeChoice = await question('Deseja restaurar Realtime Settings? (s/N): ');
    components.realtimeSettings = realtimeChoice.toLowerCase() === 's';
  }
  
  readline.close();
  return components;
}

// Mostrar resumo da restaura√ß√£o
function showRestoreSummary(backup, components, targetProject) {
  console.log(chalk.blue('\nüìã Resumo da Restaura√ß√£o:'));
  console.log(chalk.blue('‚ïê'.repeat(80)));
  console.log(chalk.cyan(`üì¶ Backup: ${backup.name}`));
  console.log(chalk.cyan(`üì§ Projeto Origem: ${backup.projectId}`));
  console.log(chalk.cyan(`üì• Projeto Destino: ${targetProject.targetProjectId}`));
  console.log('');
  console.log(chalk.cyan('Componentes que ser√£o restaurados:'));
  console.log('');
  
  console.log('‚úÖ Database (psql -f via Docker)');
  
  if (components.edgeFunctions) {
    const edgeFunctionsDir = path.join(backup.path, 'edge-functions');
    const functions = fs.readdirSync(edgeFunctionsDir).filter(item => 
      fs.statSync(path.join(edgeFunctionsDir, item)).isDirectory()
    );
    console.log(`‚ö° Edge Functions: ${functions.length} function(s)`);
    functions.forEach(func => console.log(`   - ${func}`));
  }
  
  if (components.storage) {
    console.log('üì¶ Storage Buckets: Restaurar buckets e objetos');
  }
  
  if (components.authSettings) {
    console.log('üîê Auth Settings: Restaurar configura√ß√µes de autentica√ß√£o');
  }
  
  if (components.databaseSettings) {
    console.log('üîß Database Settings: Restaurar extens√µes e configura√ß√µes');
  }
  
  if (components.realtimeSettings) {
    console.log('üîÑ Realtime Settings: Restaurar configura√ß√µes do Realtime');
  }
  
  console.log('');
}

// Confirmar execu√ß√£o
async function confirmExecution() {
  const readline = require('readline').createInterface({
    input: process.stdin,
    output: process.stdout
  });
  
  const question = (query) => new Promise(resolve => readline.question(query, resolve));
  
  const confirm = await question('Deseja continuar com a restaura√ß√£o? (s/N): ');
  readline.close();
  
  return confirm.toLowerCase() === 's';
}

// Restaurar Database via psql (conforme documenta√ß√£o oficial Supabase: https://supabase.com/docs/guides/platform/migrating-within-supabase/dashboard-restore)
async function restoreDatabaseGz(backupFilePath, targetDatabaseUrl) {
  console.log(chalk.blue('üìä Restaurando Database...'));
  console.log(chalk.gray('   - Descompactando backup (se necess√°rio)...'));
  
  try {
    const { execSync } = require('child_process');
    
    const backupDirAbs = path.resolve(path.dirname(backupFilePath));
    const fileName = path.basename(backupFilePath);
    let uncompressedFile = fileName;
    
    // Descompactar .gz se necess√°rio
    if (fileName.endsWith('.gz')) {
      console.log(chalk.gray('   - Extraindo arquivo .gz...'));
      const unzipCmd = [
        'docker run --rm',
        `-v "${backupDirAbs}:/host"`,
        'postgres:17 gunzip /host/' + fileName
      ].join(' ');
      
      execSync(unzipCmd, { stdio: 'pipe' });
      uncompressedFile = fileName.replace('.gz', '');
      console.log(chalk.gray('   - Arquivo descompactado: ' + uncompressedFile));
    }
    
    // Extrair credenciais da URL de conex√£o
    const urlMatch = targetDatabaseUrl.match(/postgresql:\/\/([^@:]+):([^@]+)@(.+)$/);
    
    if (!urlMatch) {
      throw new Error('Database URL inv√°lida. Formato esperado: postgresql://user:password@host/database');
    }
    
    // Comando psql conforme documenta√ß√£o oficial Supabase
    // Formato: psql -d [CONNECTION_STRING] -f /file/path
    // Refer√™ncia: https://supabase.com/docs/guides/platform/migrating-within-supabase/dashboard-restore
    const restoreCmd = [
      'docker run --rm --network host',
      `-v "${backupDirAbs}:/host"`,
      `-e PGPASSWORD="${encodeURIComponent(urlMatch[2])}"`,
      'postgres:17 psql',
      `-d "${targetDatabaseUrl}"`,
      `-f /host/${uncompressedFile}`
    ].join(' ');
    
    console.log(chalk.gray('   - Executando psql via Docker...'));
    console.log(chalk.gray('   ‚ÑπÔ∏è Seguindo documenta√ß√£o oficial Supabase'));
    console.log(chalk.yellow('   ‚ö†Ô∏è AVISO: Erros como "object already exists" s√£o ESPERADOS'));
    console.log(chalk.yellow('   ‚ö†Ô∏è Isto acontece porque o backup cont√©m CREATE para todos os schemas'));
    console.log(chalk.yellow('   ‚ö†Ô∏è Supabase j√° tem auth e storage criados, ent√£o esses erros s√£o normais'));
    
    // Executar comando de restaura√ß√£o
    execSync(restoreCmd, { stdio: 'inherit', encoding: 'utf8' });
    
    console.log(chalk.green('   ‚úÖ Database restaurada com sucesso!'));
    console.log(chalk.gray('   ‚ÑπÔ∏è Erros "already exists" s√£o normais e n√£o afetam a restaura√ß√£o'));
    
  } catch (error) {
    // Erros esperados conforme documenta√ß√£o oficial Supabase
    // Refer√™ncia: https://supabase.com/docs/guides/platform/migrating-within-supabase/dashboard-restore#common-errors
    if (error.message.includes('already exists') || 
        error.message.includes('constraint') ||
        error.message.includes('duplicate') ||
        error.stdout?.includes('already exists')) {
      console.log(chalk.yellow('   ‚ö†Ô∏è Erros esperados encontrados (conforme documenta√ß√£o Supabase)'));
      console.log(chalk.green('   ‚úÖ Database restaurada com sucesso!'));
      console.log(chalk.gray('   ‚ÑπÔ∏è Erros s√£o ignorados pois s√£o comandos de CREATE que j√° existem'));
    } else {
      console.error(chalk.red(`   ‚ùå Erro inesperado na restaura√ß√£o: ${error.message}`));
      throw error;
    }
  }
}

// Restaurar Edge Functions (placeholder - implementar via Management API)
async function restoreEdgeFunctions(backupPath, targetProject) {
  console.log(chalk.blue('‚ö° Restaurando Edge Functions...'));
  console.log(chalk.yellow('   ‚ÑπÔ∏è Deploy de Edge Functions via Management API ainda n√£o implementado'));
  // TODO: Implementar deploy via Supabase Management API
}

// Restaurar Storage Buckets (placeholder)
async function restoreStorageBuckets(backupPath, targetProject) {
  console.log(chalk.blue('üì¶ Restaurando Storage Buckets...'));
  console.log(chalk.yellow('   ‚ÑπÔ∏è Restaura√ß√£o de Storage Buckets ainda n√£o implementado'));
  // TODO: Implementar restaura√ß√£o via Management API
}

// Restaurar Auth Settings (placeholder)
async function restoreAuthSettings(backupPath, targetProject) {
  console.log(chalk.blue('üîê Restaurando Auth Settings...'));
  console.log(chalk.yellow('   ‚ÑπÔ∏è Restaura√ß√£o de Auth Settings ainda n√£o implementado'));
  // TODO: Implementar via Management API
}

// Restaurar Database Settings (placeholder)
async function restoreDatabaseSettings(backupPath, targetProject) {
  console.log(chalk.blue('üîß Restaurando Database Settings...'));
  console.log(chalk.yellow('   ‚ÑπÔ∏è Restaura√ß√£o de Database Settings ainda n√£o implementado'));
  // TODO: Aplicar extens√µes e configura√ß√µes via SQL
}

// Restaurar Realtime Settings (placeholder)
async function restoreRealtimeSettings(backupPath, targetProject) {
  console.log(chalk.blue('üîÑ Restaurando Realtime Settings...'));
  console.log(chalk.yellow('   ‚ÑπÔ∏è Realtime Settings requerem configura√ß√£o manual no Dashboard'));
  // TODO: Adicionar instru√ß√µes de configura√ß√£o manual
}
